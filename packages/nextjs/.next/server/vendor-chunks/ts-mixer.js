"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-mixer";
exports.ids = ["vendor-chunks/ts-mixer"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: () => (/* binding */ Mixin),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   hasMixin: () => (/* binding */ hasMixin),\n/* harmony export */   mix: () => (/* binding */ mix),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach((item) => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item) => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype)\n                .map((proto) => proto.constructor)\n                .filter((item) => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach((constituent) => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[0];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    var _a, _b, _c;\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n    decoratorsForType[key] = decoratorsForKey;\n    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkZBQTZGO0FBQzdGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixhQUFhOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlJQUF5SSxnR0FBZ0c7QUFDek8scUlBQXFJLDhGQUE4RjtBQUNuTyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSw4RkFBOEY7QUFDM08saUpBQWlKLGdHQUFnRztBQUNqUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0tBQXdLO0FBQ3hLLDBLQUEwSztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvaGVsbG8teHl6L3BhY2thZ2VzL25leHRqcy9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgd29ya3MgbGlrZSBgT2JqZWN0LmFwcGx5YCwgYnV0IGNvcGllcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHByb3Blcmx5IGFzIHdlbGwuICBBZGRpdGlvbmFsbHkgZ2l2ZXNcbiAqIHRoZSBvcHRpb24gdG8gZXhjbHVkZSBwcm9wZXJ0aWVzIGJ5IG5hbWUuXG4gKi9cbmNvbnN0IGNvcHlQcm9wcyA9IChkZXN0LCBzcmMsIGV4Y2x1ZGUgPSBbXSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc3JjKTtcbiAgICBmb3IgKGxldCBwcm9wIG9mIGV4Y2x1ZGUpXG4gICAgICAgIGRlbGV0ZSBwcm9wc1twcm9wXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZXN0LCBwcm9wcyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGNoYWluIG9mIHByb3RvdHlwZXMgdXAgdW50aWwgT2JqZWN0LnByb3RvdHlwZSBnaXZlbiBhIHN0YXJ0aW5nIG9iamVjdC4gIFRoZSBvcmRlciBvZiBwcm90b3R5cGVzIHdpbGxcbiAqIGJlIGNsb3Nlc3QgdG8gZmFydGhlc3QgaW4gdGhlIGNoYWluLlxuICovXG5jb25zdCBwcm90b0NoYWluID0gKG9iaiwgY3VycmVudENoYWluID0gW29ial0pID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIGlmIChwcm90byA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGFpbjtcbiAgICByZXR1cm4gcHJvdG9DaGFpbihwcm90bywgWy4uLmN1cnJlbnRDaGFpbiwgcHJvdG9dKTtcbn07XG4vKipcbiAqIElkZW50aWZpZXMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgY29tbW9uIHRvIGFsbCB0aGUgZ2l2ZW4gb2JqZWN0cyBpbiB0aGVpciBwcm90b3R5cGUgY2hhaW5zLiAgRm9yIG1vc3QgdW5yZWxhdGVkXG4gKiBvYmplY3RzLCB0aGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5cbiAqL1xuY29uc3QgbmVhcmVzdENvbW1vblByb3RvID0gKC4uLm9ianMpID0+IHtcbiAgICBpZiAob2Jqcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IGNvbW1vblByb3RvID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb3RvQ2hhaW5zID0gb2Jqcy5tYXAob2JqID0+IHByb3RvQ2hhaW4ob2JqKSk7XG4gICAgd2hpbGUgKHByb3RvQ2hhaW5zLmV2ZXJ5KHByb3RvQ2hhaW4gPT4gcHJvdG9DaGFpbi5sZW5ndGggPiAwKSkge1xuICAgICAgICBjb25zdCBwcm90b3MgPSBwcm90b0NoYWlucy5tYXAocHJvdG9DaGFpbiA9PiBwcm90b0NoYWluLnBvcCgpKTtcbiAgICAgICAgY29uc3QgcG90ZW50aWFsQ29tbW9uUHJvdG8gPSBwcm90b3NbMF07XG4gICAgICAgIGlmIChwcm90b3MuZXZlcnkocHJvdG8gPT4gcHJvdG8gPT09IHBvdGVudGlhbENvbW1vblByb3RvKSlcbiAgICAgICAgICAgIGNvbW1vblByb3RvID0gcG90ZW50aWFsQ29tbW9uUHJvdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uUHJvdG87XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHByb3RvdHlwZSBvYmplY3QgdGhhdCBpcyBhIG1peHR1cmUgb2YgdGhlIGdpdmVuIHByb3RvdHlwZXMuICBUaGUgbWl4aW5nIGlzIGFjaGlldmVkIGJ5IGZpcnN0XG4gKiBpZGVudGlmeWluZyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYW5kIHVzaW5nIGl0IGFzIHRoZSBwcm90b3R5cGUgZm9yIGEgbmV3IG9iamVjdC4gIFRoZW4gYWxsIHByb3BlcnRpZXMvbWV0aG9kc1xuICogZG93bnN0cmVhbSBvZiB0aGlzIHByb3RvdHlwZSAoT05MWSBkb3duc3RyZWFtKSBhcmUgY29waWVkIGludG8gdGhlIG5ldyBvYmplY3QuXG4gKlxuICogVGhlIHJlc3VsdGluZyBwcm90b3R5cGUgaXMgbW9yZSBwZXJmb3JtYW50IHRoYW4gc29mdE1peFByb3RvcyguLi4pLCBhcyB3ZWxsIGFzIEVTNSBjb21wYXRpYmxlLiAgSG93ZXZlciwgaXQncyBub3QgYXNcbiAqIGZsZXhpYmxlIGFzIHVwZGF0ZXMgdG8gdGhlIHNvdXJjZSBwcm90b3R5cGVzIGFyZW4ndCBjYXB0dXJlZCBieSB0aGUgbWl4ZWQgcmVzdWx0LiAgU2VlIHNvZnRNaXhQcm90b3MgZm9yIHdoeSB5b3UgbWF5XG4gKiB3YW50IHRvIHVzZSB0aGF0IGluc3RlYWQuXG4gKi9cbmNvbnN0IGhhcmRNaXhQcm90b3MgPSAoaW5ncmVkaWVudHMsIGNvbnN0cnVjdG9yLCBleGNsdWRlID0gW10pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYmFzZSA9IChfYSA9IG5lYXJlc3RDb21tb25Qcm90byguLi5pbmdyZWRpZW50cykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE9iamVjdC5wcm90b3R5cGU7XG4gICAgY29uc3QgbWl4ZWRQcm90byA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XG4gICAgLy8gS2VlcHMgdHJhY2sgb2YgcHJvdG90eXBlcyB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdG8gYXZvaWQgY29weWluZyB0aGUgc2FtZSBwcm9wZXJ0aWVzIG11bHRpcGxlIHRpbWVzLiAgV2UgaW5pdCB0aGVcbiAgICAvLyBsaXN0IHdpdGggdGhlIHByb3RvIGNoYWluIGJlbG93IHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55IG9mIHRob3NlIG1ldGhvZHMgbWl4ZWQgaW5cbiAgICAvLyB3aGVuIHRoZXkgd2lsbCBhbHJlYWR5IGJlIGFjY2Vzc2libGUgdmlhIHByb3RvdHlwZSBhY2Nlc3MuXG4gICAgY29uc3QgdmlzaXRlZFByb3RvcyA9IHByb3RvQ2hhaW4oYmFzZSk7XG4gICAgZm9yIChsZXQgcHJvdG90eXBlIG9mIGluZ3JlZGllbnRzKSB7XG4gICAgICAgIGxldCBwcm90b3MgPSBwcm90b0NoYWluKHByb3RvdHlwZSk7XG4gICAgICAgIC8vIEFwcGx5IHRoZSBwcm90b3R5cGUgY2hhaW4gaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IG9sZCBtZXRob2RzIGRvbid0IG92ZXJyaWRlIG5ld2VyIG9uZXMuXG4gICAgICAgIGZvciAobGV0IGkgPSBwcm90b3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm90byA9IHByb3Rvc1tpXTtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkUHJvdG9zLmluZGV4T2YobmV3UHJvdG8pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvcHlQcm9wcyhtaXhlZFByb3RvLCBuZXdQcm90bywgWydjb25zdHJ1Y3RvcicsIC4uLmV4Y2x1ZGVdKTtcbiAgICAgICAgICAgICAgICB2aXNpdGVkUHJvdG9zLnB1c2gobmV3UHJvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1peGVkUHJvdG8uY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbWl4ZWRQcm90bztcbn07XG5jb25zdCB1bmlxdWUgPSAoYXJyKSA9PiBhcnIuZmlsdGVyKChlLCBpKSA9PiBhcnIuaW5kZXhPZihlKSA9PSBpKTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5ncmVkaWVudCB3aXRoIHRoZSBnaXZlbiBwcm9wLCBzZWFyY2hpbmcgaW4gcmV2ZXJzZSBvcmRlciBhbmQgYnJlYWR0aC1maXJzdCBpZiBzZWFyY2hpbmcgaW5ncmVkaWVudFxuICogcHJvdG90eXBlcyBpcyByZXF1aXJlZC5cbiAqL1xuY29uc3QgZ2V0SW5ncmVkaWVudFdpdGhQcm9wID0gKHByb3AsIGluZ3JlZGllbnRzKSA9PiB7XG4gICAgY29uc3QgcHJvdG9DaGFpbnMgPSBpbmdyZWRpZW50cy5tYXAoaW5ncmVkaWVudCA9PiBwcm90b0NoYWluKGluZ3JlZGllbnQpKTtcbiAgICAvLyBzaW5jZSB3ZSBzZWFyY2ggYnJlYWR0aC1maXJzdCwgd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIG91ciBkZXB0aCBpbiB0aGUgcHJvdG90eXBlIGNoYWluc1xuICAgIGxldCBwcm90b0RlcHRoID0gMDtcbiAgICAvLyBub3QgYWxsIHByb3RvdHlwZSBjaGFpbnMgYXJlIHRoZSBzYW1lIGRlcHRoLCBzbyB0aGlzIHJlbWFpbnMgdHJ1ZSBhcyBsb25nIGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgaW5ncmVkaWVudHMnXG4gICAgLy8gcHJvdG90eXBlIGNoYWlucyBoYXMgYW4gb2JqZWN0IGF0IHRoaXMgZGVwdGhcbiAgICBsZXQgcHJvdG9zQXJlTGVmdFRvU2VhcmNoID0gdHJ1ZTtcbiAgICB3aGlsZSAocHJvdG9zQXJlTGVmdFRvU2VhcmNoKSB7XG4gICAgICAgIC8vIHdpdGggdGhlIHN0YXJ0IG9mIGVhY2ggaG9yaXpvbnRhbCBzbGljZSwgd2UgYXNzdW1lIHRoaXMgaXMgdGhlIG9uZSB0aGF0J3MgZGVlcGVyIHRoYW4gYW55IG9mIHRoZSBwcm90byBjaGFpbnNcbiAgICAgICAgcHJvdG9zQXJlTGVmdFRvU2VhcmNoID0gZmFsc2U7XG4gICAgICAgIC8vIHNjYW4gdGhyb3VnaCB0aGUgaW5ncmVkaWVudHMgcmlnaHQgdG8gbGVmdFxuICAgICAgICBmb3IgKGxldCBpID0gaW5ncmVkaWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFRhcmdldCA9IHByb3RvQ2hhaW5zW2ldW3Byb3RvRGVwdGhdO1xuICAgICAgICAgICAgaWYgKHNlYXJjaFRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHNlYXJjaFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZpbmQgc29tZXRoaW5nLCB0aGlzIGlzIHByb29mIHRoYXQgdGhpcyBob3Jpem9udGFsIHNsaWNlIHBvdGVudGlhbGx5IG1vcmUgb2JqZWN0cyB0byBzZWFyY2hcbiAgICAgICAgICAgICAgICBwcm90b3NBcmVMZWZ0VG9TZWFyY2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGV1cmVrYSwgd2UgZm91bmQgaXRcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzZWFyY2hUYXJnZXQsIHByb3ApICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9DaGFpbnNbaV1bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3RvRGVwdGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIFwiTWl4ZXNcIiBpbmdyZWRpZW50cyBieSB3cmFwcGluZyB0aGVtIGluIGEgUHJveHkuICBUaGUgb3B0aW9uYWwgcHJvdG90eXBlIGFyZ3VtZW50IGFsbG93cyB0aGUgbWl4ZWQgb2JqZWN0IHRvIHNpdFxuICogZG93bnN0cmVhbSBvZiBhbiBleGlzdGluZyBwcm90b3R5cGUgY2hhaW4uICBOb3RlIHRoYXQgXCJwcm9wZXJ0aWVzXCIgY2Fubm90IGJlIGFkZGVkLCBkZWxldGVkLCBvciBtb2RpZmllZC5cbiAqL1xuY29uc3QgcHJveHlNaXggPSAoaW5ncmVkaWVudHMsIHByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGUpID0+IG5ldyBQcm94eSh7fSwge1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlO1xuICAgIH0sXG4gICAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cykgfHwge30sIHByb3ApO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlZmluZSBuZXcgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICB9LFxuICAgIGhhcyhfLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpICE9PSB1bmRlZmluZWQgfHwgcHJvdG90eXBlW3Byb3BdICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXQoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gKGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cykgfHwgcHJvdG90eXBlKVtwcm9wXTtcbiAgICB9LFxuICAgIHNldChfLCBwcm9wLCB2YWwpIHtcbiAgICAgICAgY29uc3QgaW5ncmVkaWVudFdpdGhQcm9wID0gZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKTtcbiAgICAgICAgaWYgKGluZ3JlZGllbnRXaXRoUHJvcCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG5ldyBwcm9wZXJ0aWVzIG9uIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgICAgICBpbmdyZWRpZW50V2l0aFByb3BbcHJvcF0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0aWVzIG9uIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIGluZ3JlZGllbnRzXG4gICAgICAgICAgICAubWFwKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKVxuICAgICAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4gY3Vyci5jb25jYXQocHJldi5maWx0ZXIoa2V5ID0+IGN1cnIuaW5kZXhPZihrZXkpIDwgMCkpKTtcbiAgICB9LFxufSk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcHJveHktcHJvdG90eXBlIG9iamVjdCB0aGF0IGlzIGEgXCJzb2Z0XCIgbWl4dHVyZSBvZiB0aGUgZ2l2ZW4gcHJvdG90eXBlcy4gIFRoZSBtaXhpbmcgaXMgYWNoaWV2ZWQgYnlcbiAqIHByb3h5aW5nIGFsbCBwcm9wZXJ0eSBhY2Nlc3MgdG8gdGhlIGluZ3JlZGllbnRzLiAgVGhpcyBpcyBub3QgRVM1IGNvbXBhdGlibGUgYW5kIGxlc3MgcGVyZm9ybWFudC4gIEhvd2V2ZXIsIGFueVxuICogY2hhbmdlcyBtYWRlIHRvIHRoZSBzb3VyY2UgcHJvdG90eXBlcyB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGUgcHJveHktcHJvdG90eXBlLCB3aGljaCBtYXkgYmUgZGVzaXJhYmxlLlxuICovXG5jb25zdCBzb2Z0TWl4UHJvdG9zID0gKGluZ3JlZGllbnRzLCBjb25zdHJ1Y3RvcikgPT4gcHJveHlNaXgoWy4uLmluZ3JlZGllbnRzLCB7IGNvbnN0cnVjdG9yIH1dKTtcblxuY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgaW5pdEZ1bmN0aW9uOiBudWxsLFxuICAgIHN0YXRpY3NTdHJhdGVneTogJ2NvcHknLFxuICAgIHByb3RvdHlwZVN0cmF0ZWd5OiAnY29weScsXG4gICAgZGVjb3JhdG9ySW5oZXJpdGFuY2U6ICdkZWVwJyxcbn07XG5cbi8vIEtlZXBzIHRyYWNrIG9mIGNvbnN0aXR1ZW50IGNsYXNzZXMgZm9yIGV2ZXJ5IG1peGluIGNsYXNzIGNyZWF0ZWQgYnkgdHMtbWl4ZXIuXG5jb25zdCBtaXhpbnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZ2V0TWl4aW5zRm9yQ2xhc3MgPSAoY2xhenopID0+IG1peGlucy5nZXQoY2xhenopO1xuY29uc3QgcmVnaXN0ZXJNaXhpbnMgPSAobWl4ZWRDbGFzcywgY29uc3RpdHVlbnRzKSA9PiBtaXhpbnMuc2V0KG1peGVkQ2xhc3MsIGNvbnN0aXR1ZW50cyk7XG5jb25zdCBoYXNNaXhpbiA9IChpbnN0YW5jZSwgbWl4aW4pID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBtaXhpbilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGxldCBmcm9udGllciA9IG5ldyBTZXQoKTtcbiAgICBmcm9udGllci5hZGQoY29uc3RydWN0b3IpO1xuICAgIHdoaWxlIChmcm9udGllci5zaXplID4gMCkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJvbnRpZXIgaGFzIHRoZSBtaXhpbiB3ZSdyZSBsb29raW5nIGZvci4gIGlmIG5vdCwgd2UgY2FuIHNheSB3ZSB2aXNpdGVkIGV2ZXJ5IGl0ZW0gaW4gdGhlIGZyb250aWVyXG4gICAgICAgIGlmIChmcm9udGllci5oYXMobWl4aW4pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZyb250aWVyLmZvckVhY2goKGl0ZW0pID0+IHZpc2l0ZWQuYWRkKGl0ZW0pKTtcbiAgICAgICAgLy8gYnVpbGQgYSBuZXcgZnJvbnRpZXIgYmFzZWQgb24gdGhlIGFzc29jaWF0ZWQgbWl4aW4gY2xhc3NlcyBhbmQgcHJvdG90eXBlIGNoYWlucyBvZiBlYWNoIGZyb250aWVyIGl0ZW1cbiAgICAgICAgY29uc3QgbmV3RnJvbnRpZXIgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZyb250aWVyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db25zdGl0dWVudHMgPSAoX2EgPSBtaXhpbnMuZ2V0KGl0ZW0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm90b0NoYWluKGl0ZW0ucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIC5tYXAoKHByb3RvKSA9PiBwcm90by5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChpdGVtQ29uc3RpdHVlbnRzKVxuICAgICAgICAgICAgICAgIGl0ZW1Db25zdGl0dWVudHMuZm9yRWFjaCgoY29uc3RpdHVlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjb25zdGl0dWVudCkgJiYgIWZyb250aWVyLmhhcyhjb25zdGl0dWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGcm9udGllci5hZGQoY29uc3RpdHVlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIG5ldyBmcm9udGllciwgbm93IHNlYXJjaCBhZ2FpblxuICAgICAgICBmcm9udGllciA9IG5ld0Zyb250aWVyO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgd2UgY291bGRuJ3QgZmluZCB0aGUgbWl4aW4gYW55d2hlcmUgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvciBhc3NvY2lhdGVkIG1peGluIGNsYXNzZXNcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMgPSAobzEsIG8yKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBhbGxLZXlzID0gdW5pcXVlKFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvMSksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8yKV0pO1xuICAgIGNvbnN0IG1lcmdlZE9iamVjdCA9IHt9O1xuICAgIGZvciAobGV0IGtleSBvZiBhbGxLZXlzKVxuICAgICAgICBtZXJnZWRPYmplY3Rba2V5XSA9IHVuaXF1ZShbLi4uKChfYSA9IG8xID09PSBudWxsIHx8IG8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvMVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSksIC4uLigoX2IgPSBvMiA9PT0gbnVsbCB8fCBvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbzJba2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pXSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdDtcbn07XG5jb25zdCBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycyA9IChkMSwgZDIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuICh7XG4gICAgICAgIHByb3BlcnR5OiBtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMoKF9hID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLnByb3BlcnR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgKF9iID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLnByb3BlcnR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSksXG4gICAgICAgIG1ldGhvZDogbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzKChfYyA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5tZXRob2QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCAoX2QgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIubWV0aG9kKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSksXG4gICAgfSk7XG59O1xuY29uc3QgbWVyZ2VEZWNvcmF0b3JzID0gKGQxLCBkMikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiAoe1xuICAgICAgICBjbGFzczogdW5pcXVlKFsuLi4oX2EgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuY2xhc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCAuLi4oX2IgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuY2xhc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdXSksXG4gICAgICAgIHN0YXRpYzogbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMoKF9jID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLnN0YXRpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIChfZCA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5zdGF0aWMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KSxcbiAgICAgICAgaW5zdGFuY2U6IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzKChfZSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30sIChfZiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDoge30pLFxuICAgIH0pO1xufTtcbmNvbnN0IGRlY29yYXRvcnMgPSBuZXcgTWFwKCk7XG5jb25zdCBmaW5kQWxsQ29uc3RpdHVlbnRDbGFzc2VzID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBmcm9udGllciA9IG5ldyBTZXQoWy4uLmNsYXNzZXNdKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgY2xhenogb2YgZnJvbnRpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvQ2hhaW5DbGFzc2VzID0gcHJvdG9DaGFpbihjbGF6ei5wcm90b3R5cGUpLm1hcChwcm90byA9PiBwcm90by5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBtaXhpbkNsYXNzZXMgPSAoX2EgPSBnZXRNaXhpbnNGb3JDbGFzcyhjbGF6eikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsbHlOZXdDbGFzc2VzID0gWy4uLnByb3RvQ2hhaW5DbGFzc2VzLCAuLi5taXhpbkNsYXNzZXNdO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBvdGVudGlhbGx5TmV3Q2xhc3Nlcy5maWx0ZXIoYyA9PiAhYWxsQ2xhc3Nlcy5oYXMoYykpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Q2xhc3Mgb2YgbmV3Q2xhc3NlcylcbiAgICAgICAgICAgICAgICBmcm9udGllci5hZGQobmV3Q2xhc3MpO1xuICAgICAgICAgICAgYWxsQ2xhc3Nlcy5hZGQoY2xhenopO1xuICAgICAgICAgICAgZnJvbnRpZXIuZGVsZXRlKGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLmFsbENsYXNzZXNdO1xufTtcbmNvbnN0IGRlZXBEZWNvcmF0b3JTZWFyY2ggPSAoLi4uY2xhc3NlcykgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JDbGFzc0NoYWluID0gZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyguLi5jbGFzc2VzKVxuICAgICAgICAubWFwKGNsYXp6ID0+IGRlY29yYXRvcnMuZ2V0KGNsYXp6KSlcbiAgICAgICAgLmZpbHRlcihkZWNvcmF0b3JzID0+ICEhZGVjb3JhdG9ycyk7XG4gICAgaWYgKGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLmxlbmd0aCA9PSAxKVxuICAgICAgICByZXR1cm4gZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW5bMF07XG4gICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLnJlZHVjZSgoZDEsIGQyKSA9PiBtZXJnZURlY29yYXRvcnMoZDEsIGQyKSk7XG59O1xuY29uc3QgZGlyZWN0RGVjb3JhdG9yU2VhcmNoID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICBjb25zdCBjbGFzc0RlY29yYXRvcnMgPSBjbGFzc2VzLm1hcChjbGF6eiA9PiBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopKTtcbiAgICBpZiAoY2xhc3NEZWNvcmF0b3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChjbGFzc0RlY29yYXRvcnMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gY2xhc3NEZWNvcmF0b3JzWzBdO1xuICAgIHJldHVybiBjbGFzc0RlY29yYXRvcnMucmVkdWNlKChkMSwgZDIpID0+IG1lcmdlRGVjb3JhdG9ycyhkMSwgZDIpKTtcbn07XG5jb25zdCBnZXREZWNvcmF0b3JzRm9yQ2xhc3MgPSAoY2xhenopID0+IHtcbiAgICBsZXQgZGVjb3JhdG9yc0ZvckNsYXNzID0gZGVjb3JhdG9ycy5nZXQoY2xhenopO1xuICAgIGlmICghZGVjb3JhdG9yc0ZvckNsYXNzKSB7XG4gICAgICAgIGRlY29yYXRvcnNGb3JDbGFzcyA9IHt9O1xuICAgICAgICBkZWNvcmF0b3JzLnNldChjbGF6eiwgZGVjb3JhdG9yc0ZvckNsYXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzcztcbn07XG5jb25zdCBkZWNvcmF0ZUNsYXNzID0gKGRlY29yYXRvcikgPT4gKChjbGF6eikgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGdldERlY29yYXRvcnNGb3JDbGFzcyhjbGF6eik7XG4gICAgbGV0IGNsYXNzRGVjb3JhdG9ycyA9IGRlY29yYXRvcnNGb3JDbGFzcy5jbGFzcztcbiAgICBpZiAoIWNsYXNzRGVjb3JhdG9ycykge1xuICAgICAgICBjbGFzc0RlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgZGVjb3JhdG9yc0ZvckNsYXNzLmNsYXNzID0gY2xhc3NEZWNvcmF0b3JzO1xuICAgIH1cbiAgICBjbGFzc0RlY29yYXRvcnMucHVzaChkZWNvcmF0b3IpO1xuICAgIHJldHVybiBkZWNvcmF0b3IoY2xhenopO1xufSk7XG5jb25zdCBkZWNvcmF0ZU1lbWJlciA9IChkZWNvcmF0b3IpID0+ICgob2JqZWN0LCBrZXksIC4uLm90aGVyQXJncykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGRlY29yYXRvclRhcmdldFR5cGUgPSB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nID8gJ3N0YXRpYycgOiAnaW5zdGFuY2UnO1xuICAgIGNvbnN0IGRlY29yYXRvclR5cGUgPSB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicgPyAnbWV0aG9kJyA6ICdwcm9wZXJ0eSc7XG4gICAgY29uc3QgY2xhenogPSBkZWNvcmF0b3JUYXJnZXRUeXBlID09PSAnc3RhdGljJyA/IG9iamVjdCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopO1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlID0gKF9hID0gZGVjb3JhdG9yc0ZvckNsYXNzID09PSBudWxsIHx8IGRlY29yYXRvcnNGb3JDbGFzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvckNsYXNzW2RlY29yYXRvclRhcmdldFR5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBkZWNvcmF0b3JzRm9yQ2xhc3NbZGVjb3JhdG9yVGFyZ2V0VHlwZV0gPSBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZTtcbiAgICBsZXQgZGVjb3JhdG9yc0ZvclR5cGUgPSAoX2IgPSBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvclRhcmdldFR5cGVbZGVjb3JhdG9yVHlwZV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgIGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlW2RlY29yYXRvclR5cGVdID0gZGVjb3JhdG9yc0ZvclR5cGU7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JLZXkgPSAoX2MgPSBkZWNvcmF0b3JzRm9yVHlwZSA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvclR5cGVba2V5XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgZGVjb3JhdG9yc0ZvclR5cGVba2V5XSA9IGRlY29yYXRvcnNGb3JLZXk7XG4gICAgLy8gQHRzLWlnbm9yZTogYXJyYXkgaXMgdHlwZSBgQVtdIHwgQltdYCBhbmQgaXRlbSBpcyB0eXBlIGBBIHwgQmAsIHNvIHRlY2huaWNhbGx5IGEgdHlwZSBlcnJvciwgYnV0IGl0J3MgZmluZVxuICAgIGRlY29yYXRvcnNGb3JLZXkucHVzaChkZWNvcmF0b3IpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZGVjb3JhdG9yKG9iamVjdCwga2V5LCAuLi5vdGhlckFyZ3MpO1xufSk7XG5jb25zdCBkZWNvcmF0ZSA9IChkZWNvcmF0b3IpID0+ICgoLi4uYXJncykgPT4ge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlQ2xhc3MoZGVjb3JhdG9yKShhcmdzWzBdKTtcbiAgICByZXR1cm4gZGVjb3JhdGVNZW1iZXIoZGVjb3JhdG9yKSguLi5hcmdzKTtcbn0pO1xuXG5mdW5jdGlvbiBNaXhpbiguLi5jb25zdHJ1Y3RvcnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBwcm90b3R5cGVzID0gY29uc3RydWN0b3JzLm1hcChjb25zdHJ1Y3RvciA9PiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIC8vIEhlcmUgd2UgZ2F0aGVyIHVwIHRoZSBpbml0IGZ1bmN0aW9ucyBvZiB0aGUgaW5ncmVkaWVudCBwcm90b3R5cGVzLCBjb21iaW5lIHRoZW0gaW50byBvbmUgaW5pdCBmdW5jdGlvbiwgYW5kXG4gICAgLy8gYXR0YWNoIGl0IHRvIHRoZSBtaXhlZCBjbGFzcyBwcm90b3R5cGUuICBUaGUgcmVhc29uIHdlIGRvIHRoaXMgaXMgYmVjYXVzZSB3ZSB3YW50IHRoZSBpbml0IGZ1bmN0aW9ucyB0byBtaXhcbiAgICAvLyBzaW1pbGFybHkgdG8gY29uc3RydWN0b3JzIC0tIG5vdCBtZXRob2RzLCB3aGljaCBzaW1wbHkgb3ZlcnJpZGUgZWFjaCBvdGhlci5cbiAgICBjb25zdCBpbml0RnVuY3Rpb25OYW1lID0gc2V0dGluZ3MuaW5pdEZ1bmN0aW9uO1xuICAgIGlmIChpbml0RnVuY3Rpb25OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGluaXRGdW5jdGlvbnMgPSBwcm90b3R5cGVzXG4gICAgICAgICAgICAubWFwKHByb3RvID0+IHByb3RvW2luaXRGdW5jdGlvbk5hbWVdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jID0+IHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgY29tYmluZWRJbml0RnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5pdEZ1bmN0aW9uIG9mIGluaXRGdW5jdGlvbnMpXG4gICAgICAgICAgICAgICAgaW5pdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleHRyYVByb3RvID0geyBbaW5pdEZ1bmN0aW9uTmFtZV06IGNvbWJpbmVkSW5pdEZ1bmN0aW9uIH07XG4gICAgICAgIHByb3RvdHlwZXMucHVzaChleHRyYVByb3RvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWl4ZWRDbGFzcyguLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29uc3RydWN0b3Igb2YgY29uc3RydWN0b3JzKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogcG90ZW50aWFsbHkgYWJzdHJhY3QgY2xhc3NcbiAgICAgICAgICAgIGNvcHlQcm9wcyh0aGlzLCBuZXcgY29uc3RydWN0b3IoLi4uYXJncykpO1xuICAgICAgICBpZiAoaW5pdEZ1bmN0aW9uTmFtZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpc1tpbml0RnVuY3Rpb25OYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRoaXNbaW5pdEZ1bmN0aW9uTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIE1peGVkQ2xhc3MucHJvdG90eXBlID0gc2V0dGluZ3MucHJvdG90eXBlU3RyYXRlZ3kgPT09ICdjb3B5J1xuICAgICAgICA/IGhhcmRNaXhQcm90b3MocHJvdG90eXBlcywgTWl4ZWRDbGFzcylcbiAgICAgICAgOiBzb2Z0TWl4UHJvdG9zKHByb3RvdHlwZXMsIE1peGVkQ2xhc3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihNaXhlZENsYXNzLCBzZXR0aW5ncy5zdGF0aWNzU3RyYXRlZ3kgPT09ICdjb3B5J1xuICAgICAgICA/IGhhcmRNaXhQcm90b3MoY29uc3RydWN0b3JzLCBudWxsLCBbJ3Byb3RvdHlwZSddKVxuICAgICAgICA6IHByb3h5TWl4KGNvbnN0cnVjdG9ycywgRnVuY3Rpb24ucHJvdG90eXBlKSk7XG4gICAgbGV0IERlY29yYXRlZE1peGVkQ2xhc3MgPSBNaXhlZENsYXNzO1xuICAgIGlmIChzZXR0aW5ncy5kZWNvcmF0b3JJbmhlcml0YW5jZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzRGVjb3JhdG9ycyA9IHNldHRpbmdzLmRlY29yYXRvckluaGVyaXRhbmNlID09PSAnZGVlcCdcbiAgICAgICAgICAgID8gZGVlcERlY29yYXRvclNlYXJjaCguLi5jb25zdHJ1Y3RvcnMpXG4gICAgICAgICAgICA6IGRpcmVjdERlY29yYXRvclNlYXJjaCguLi5jb25zdHJ1Y3RvcnMpO1xuICAgICAgICBmb3IgKGxldCBkZWNvcmF0b3Igb2YgKF9hID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLmNsYXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb3JhdG9yKERlY29yYXRlZE1peGVkQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIERlY29yYXRlZE1peGVkQ2xhc3MgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlQcm9wQW5kTWV0aG9kRGVjb3JhdG9ycygoX2IgPSBjbGFzc0RlY29yYXRvcnMgPT09IG51bGwgfHwgY2xhc3NEZWNvcmF0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc0RlY29yYXRvcnMuc3RhdGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgRGVjb3JhdGVkTWl4ZWRDbGFzcyk7XG4gICAgICAgIGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMoKF9jID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLmluc3RhbmNlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgRGVjb3JhdGVkTWl4ZWRDbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cbiAgICByZWdpc3Rlck1peGlucyhEZWNvcmF0ZWRNaXhlZENsYXNzLCBjb25zdHJ1Y3RvcnMpO1xuICAgIHJldHVybiBEZWNvcmF0ZWRNaXhlZENsYXNzO1xufVxuY29uc3QgYXBwbHlQcm9wQW5kTWV0aG9kRGVjb3JhdG9ycyA9IChwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycywgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgcHJvcERlY29yYXRvcnMgPSBwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycy5wcm9wZXJ0eTtcbiAgICBjb25zdCBtZXRob2REZWNvcmF0b3JzID0gcHJvcEFuZE1ldGhvZERlY29yYXRvcnMubWV0aG9kO1xuICAgIGlmIChwcm9wRGVjb3JhdG9ycylcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3BEZWNvcmF0b3JzKVxuICAgICAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIHByb3BEZWNvcmF0b3JzW2tleV0pXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5KTtcbiAgICBpZiAobWV0aG9kRGVjb3JhdG9ycylcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1ldGhvZERlY29yYXRvcnMpXG4gICAgICAgICAgICBmb3IgKGxldCBkZWNvcmF0b3Igb2YgbWV0aG9kRGVjb3JhdG9yc1trZXldKVxuICAgICAgICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpO1xufTtcbi8qKlxuICogQSBkZWNvcmF0b3IgdmVyc2lvbiBvZiB0aGUgYE1peGluYCBmdW5jdGlvbi4gIFlvdSdsbCB3YW50IHRvIHVzZSB0aGlzIGluc3RlYWQgb2YgYE1peGluYCBmb3IgbWl4aW5nIGdlbmVyaWMgY2xhc3Nlcy5cbiAqL1xuY29uc3QgbWl4ID0gKC4uLmluZ3JlZGllbnRzKSA9PiBkZWNvcmF0ZWRDbGFzcyA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1peGVkQ2xhc3MgPSBNaXhpbiguLi5pbmdyZWRpZW50cy5jb25jYXQoW2RlY29yYXRlZENsYXNzXSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtaXhlZENsYXNzLCAnbmFtZScsIHtcbiAgICAgICAgdmFsdWU6IGRlY29yYXRlZENsYXNzLm5hbWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbWl4ZWRDbGFzcztcbn07XG5cbmV4cG9ydCB7IE1peGluLCBkZWNvcmF0ZSwgaGFzTWl4aW4sIG1peCwgc2V0dGluZ3MgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-mixer/dist/esm/index.js\n");

/***/ })

};
;